<?R 
	source("conf.R")
	c_header();
	source("lib/feq.R")
	source("lib/boundary.R")
	source("lib/lattice.R")
?>

// 04/02/2017 - Model Developed: A. Fakhari, T. Mitchell
//	      - Implementation:	 T. Mitchell

// Model for Physical Review E article:
//
// """" Improved locality of the phase-field lattice Boltzmann 
//	model for immiscible fluids at high density ratios 	    """"
//
// Authors: A. Fakhari, T. Mitchell, C. Leonardi, D. Bolster (2017) """"
// DOI: 10.1103/PhysRevE.96.053301


// Maintainer: Travis-Mitchell @TravisMitchell
// Code updates:
//		04/02/2017: Development starts...
//		- Verification/Validation:
//			Poiseuille flow
//			Rayleigh Taylor
//			Taylor bubble rise
//		24/07/2017: Options added for Reviewer comments:
//			  : didn't notice any macroscopic difference in soln's
//			- A: Higher order Guo forcing term
//			- B: Time dependent term in phase field from Ren et al (2016)
//		14/08/2017: Added in boundary conditions:
// 			- Moving walls seem to work well for bubble deformation
//			- Pressure/velocity not fully tested - use at your own PERIL!


// Maintainer & Implementation: Grzegorz Gruszczynski @ggruszczynski
// Code updates:
//		16/08/2018: Cascaded collision scheme

#include <math.h>
#define PI 3.1415926535897

<?R
g = PV(Density$name[Density$group == "g"])
h = PV(Density$name[Density$group == "h"])

if (Options$Outflow){
	g_neighbours = Density$nicename[Density$group == "g"]
	h_neighbours = Density$nicename[Density$group == "h"]
	g_old = PV(Density$name[Density$group == "gold"])
	h_old = PV(Density$name[Density$group == "hold"])
	g_n = PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],")",sep=""))
	h_n = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")",sep=""))
	g_n1 = PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"],",",-Density$dy[Density$group=="g"]-1,")",sep=""))
	h_n1 = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"],",",-Density$dy[Density$group=="h"]-1,")",sep=""))
	U_loc = PV("U_local")
	U_inv = PV("invU")
}
?>
//	EXPORTABLE QUANTITIES:
<?R if(Options$ML){
        for (myDensity in 0:8){
            cat(paste0("CudaDeviceFunction real_t getg",myDensity,"(){\n"))
            cat(paste0("\t return g[",myDensity,"];\n"))
            cat("}\n")
            cat(paste0("CudaDeviceFunction real_t geth",myDensity,"(){\n"))
            cat(paste0("\t return h[",myDensity,"];\n"))
            cat("}\n")
        }
    }
?>

CudaDeviceFunction real_t getRho(){
	real_t rho;
	rho = Density_l + (Density_h-Density_l) * (PhaseF(0,0) - PhaseField_l)/(PhaseField_h - PhaseField_l);
	return rho;
}

CudaDeviceFunction real_t getPhaseField(){
	return PhaseF(0,0);
}

CudaDeviceFunction vector_t getU(){
	vector_t u;
	u.x = U;
	u.y = V;
	u.z = 0.0;
	return u;
}

CudaDeviceFunction real_t getNormalizedPressure(){
	// Normalised pressure, eq 32a from "Improved locality of the phase-field lattice Boltzmann 
	//model for immiscible fluids at high density ratios"
	real_t p =  <?R C(sum(g)) ?> ;
	return p;
}

CudaDeviceFunction real_t getPressure(){
	// Pressure, defined just eq 17 from "Improved locality of the phase-field lattice Boltzmann 
	//	model for immiscible fluids at high density ratios"
	real_t p =  <?R C(sum(g)) ?> ;//Normalised pressure
	real_t rho = getRho();
	p = p*rho/3.0; 
	return p;
}

CudaDeviceFunction vector_t getNormal(){
	vector_t normal;
	normal.x = nw_x;
	normal.y = nw_y;
	normal.z = 0.0;
	return normal;
}

// 	HELPER FUNCTIONS:
CudaDeviceFunction vector_t calcGradPhi(){
	vector_t gradPhi;
	// eq 34 from "Improved locality of the phase-field lattice Boltzmann 
	//	model for immiscible fluids at high density ratios"
	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Neumann_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_E) {
			gradPhi.x = 0.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(-1,1) - PhaseF(-1,-1) )/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Convective_N) {
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,-1) - PhaseF(-1,-1) )/6.0;
			gradPhi.y = 0.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		} else if (NodeType & NODE_BOUNDARY){
			gradPhi.x = 0.0;
			gradPhi.y = 0.0;
		} else { 
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		}
	#else
		if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_EOutflow_ML){
            gradPhi.x = (PhaseF(0,0) - PhaseF(-1,0));
            gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/2.0;
        } else if (NodeType & NODE_BOUNDARY){
			gradPhi.x = 0.0;
			gradPhi.y = 0.0;
		} else { 
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		}
	#endif
		gradPhi.z = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + 1e-12); // length
		return gradPhi;
}

CudaDeviceFunction real_t get_lpPhi(real_t myPhase){
	// input myPhase - PhaseF at given node (usually 0,0 or the one from BC)

	// lpPhi - eq 35 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t lpPhi = PhaseF(1,1)+PhaseF(-1,1)+PhaseF(1,-1)+PhaseF(-1,-1)
	               + 4.0*(PhaseF(1,0)+PhaseF(-1,0)+PhaseF(0,1)+PhaseF(0,-1))
	               - 20.0*myPhase;
	lpPhi /= 6.0;

	return lpPhi;
}

CudaDeviceFunction real_t calcMu(real_t myPhase){
	// input myPhase - PhaseF at given node (usually 0,0 or the one from BC)

	real_t lpPhi;

	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Neumann_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_E) {
			lpPhi = (PhaseF(-1,1)+PhaseF(-1,1)+PhaseF(-1,-1)+PhaseF(-1,-1) +
						4.0*(PhaseF(-1,0)+PhaseF(-1,0)+PhaseF(0,1)+PhaseF(0,-1) ) -
						20.0*myPhase)/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Convective_N) {
			lpPhi = (PhaseF(1,-1)+PhaseF(-1,-1)+PhaseF(1,-1)+PhaseF(-1,-1) +
						4.0*(PhaseF(1,0)+PhaseF(-1,0)+PhaseF(0,-1)+PhaseF(0,-1) ) -
						20.0*myPhase)/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			lpPhi = get_lpPhi(myPhase);
		} else if (NodeType & NODE_BOUNDARY){
			lpPhi = 0.0;
		} else {
			lpPhi = get_lpPhi(myPhase);
		}
	#else
		if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			lpPhi = get_lpPhi(myPhase);
		} else if (NodeType & NODE_BOUNDARY){
			lpPhi = 0.0;
		} else {
			lpPhi = get_lpPhi(myPhase);
		}
	#endif

	// eq 5 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
	real_t mu = 4.0*(12.0*sigma/W)*(myPhase-PhaseField_l)*(myPhase-PhaseField_h)*(myPhase-pfavg)
		        - (1.5 *sigma*W) * lpPhi; 
	return mu;
}

CudaDeviceFunction real_t calcGamma(int i, real_t u, real_t v, real_t u2mag){
	// eq 10 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t gamma, tmp;
	tmp = (d2q9_ex[i]*u+d2q9_ey[i]*v);

	gamma = wf[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcF_phi(int i, real_t numerator, real_t nx, real_t ny){
	// eq 7 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"

	// nx: normalized PhaseField gradient in x direction
	// this method calculates F_phi in [0-9] lattice coord

	real_t f_phi;
	f_phi = wf[i] * numerator * (d2q9_ex[i]*nx + d2q9_ey[i]*ny);
	return f_phi;
}

CudaDeviceFunction vector_t calcF_phi_xy(vector_t gradPhi, real_t myPhaseF, real_t pfavg){	
	// eq 7 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"

	// this method calculates F_phi in x,y coordinates
	real_t nx = gradPhi.x/gradPhi.z;  // GradPhi normalized in x, y direction
	real_t ny = gradPhi.y/gradPhi.z;

	real_t F_phi_coeff = (1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/(3.0*W);

	vector_t f_phi;	
	f_phi.x=F_phi_coeff*nx;
	f_phi.y=F_phi_coeff*ny;
	return f_phi;
}

CudaDeviceFunction real_t calcTau(real_t myPhaseF, real_t myRho)
{
	real_t tau;

	if ( myPhaseF < PhaseField_l){
		tau = tau_l + 0.5;
	} else if (myPhaseF > PhaseField_h) {
		tau = tau_h + 0.5;
	} else {
		real_t normPhaseF = (myPhaseF - PhaseField_l)/(PhaseField_h - PhaseField_l);
		// Linear update: eq23
		tau = 0.5 + tau_l + normPhaseF*(tau_h - tau_l);

	// There are a number of ways to update the relaxation time through the interface
	//		a number of these are supplied here for the interested user:
	// Inverse update: eq22
		//tau = normPhaseF * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
		//tau = 1.0/tau + 0.5;

	// Sharp update:		
		// real_t pf_avg = (PhaseField_h + PhaseField_l)/2.;
		// tau = (myPhaseF >= pf_avg) ? 0.5 + tau_h : 0.5 + tau_l;
		// real_t mu_h = Viscosity_h * myRho;
		// real_t mu_l = Viscosity_l * myRho;
		// tau = (myPhaseF >= pf_avg) ? 0.5 + 3*mu_h/Density_h : 0.5 + 3*mu_l/Density_l;

	// Viscosity update: eq24 & 25
		// real_t DynVisc = Density_l*Viscosity_l + normPhaseF* (Density_h*Viscosity_h - Density_l*Viscosity_l);
		// tau = 3.0 * DynVisc / myRho + 0.5;
	
	// Zu and He (2013): eq29c
		// real_t DynVisc = Density_l*Viscosity_l * Density_h*Viscosity_h * (PhaseField_h - PhaseField_l)
		//					/ ((myPhaseF-PhaseField_l)*Density_l*Viscosity_l  
		//					  +(PhaseField_h-myPhaseF)*Density_h*Viscosity_h    ) ;
		// tau = 3.0 * DynVisc / myRho + 0.5;
	}

	return tau;
}

CudaDeviceFunction real_t calcRho(real_t myPhaseF)
{
	// Linear update:
	real_t rho = Density_l + (myPhaseF - PhaseField_l)*(Density_h - Density_l) / (PhaseField_h - PhaseField_l);
	
	// Sharp update:
	// 	not recommended
	// real_t pf_avg = (PhaseField_h + PhaseField_l)/2.;
	// real_t rho = (myPhaseF >= pf_avg) ? Density_h : Density_l;
	return rho;
}

//	INITIALISATION:
CudaDeviceFunction void Init_phase() {
	PhaseF = PhaseField_init;// read initial PhaseField distribution from config.xml file

	// RAYLEIGH TAYLOR INSTABILITY
	if ( Period > 0 ) {
	    real_t InterfacePoint = MidPoint + Perturbation*Period*cos(2.0*PI*X/Period);
	    PhaseF = 0.5 * (PhaseField_h + PhaseField_l)
		   + 0.5 * (PhaseField_h - PhaseField_l) * tanh(2.0 * (Y - InterfacePoint)/W);
	}
	// DIFFUSE INTERFACE CIRCLE
	if ( Radius > 0 ) {
	    real_t Ri;
	    Ri = sqrt( (X - CenterX)*(X - CenterX) + (Y - CenterY)*(Y - CenterY) );
	    PhaseF = 0.5 * (PhaseField_h + PhaseField_l)
		   - 0.5 * (PhaseField_h - PhaseField_l) * BubbleType * tanh(2.0*(Ri - Radius)/W);
	}
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) PhaseF = -999;
}

CudaDeviceFunction void Init_wallNorm(){
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) {
		int solidFlags[9], i;
		solidFlags[0] = PhaseF(0,0)  /-998;
		solidFlags[1] = PhaseF(1,0)  /-998;
		solidFlags[2] = PhaseF(0,1)  /-998;
		solidFlags[3] = PhaseF(-1,0) /-998;
		solidFlags[4] = PhaseF(0,-1) /-998;
		solidFlags[5] = PhaseF(1,1)  /-998;
		solidFlags[6] = PhaseF(-1,1 )/-998;
		solidFlags[7] = PhaseF(-1,-1)/-998;
		solidFlags[8] = PhaseF(1,-1) /-998;

		real_t myNorm[2]={0.0,0.0};
		for (i = 0 ; i < 9; i++){
			myNorm[0] += wf[i]*d2q9_ex[i]*solidFlags[i];
			myNorm[1] += wf[i]*d2q9_ey[i]*solidFlags[i];	
		}
		myNorm[0] *= -1.0/3.0;
		myNorm[1] *= -1.0/3.0;

		real_t dot, maxn=0.0;
		int maxi=0;

		for (i = 0; i<9; i++) {
			dot = (myNorm[0]*d2q9_ex[i] + myNorm[1]*d2q9_ey[i])/ 
			      sqrt( (myNorm[0]*myNorm[0] + myNorm[1]*myNorm[1])*(d2q9_ex[i]*d2q9_ex[i] + d2q9_ey[i]*d2q9_ey[i]+1e-12 ));
		
			if (dot > maxn) {
				maxn = dot;
				maxi = i;
			}
		}

		nw_x = d2q9_ex[maxi];
		nw_y = d2q9_ey[maxi];
	} else {
		nw_x = 0.0; nw_y = 0.0;
	}
}

CudaDeviceFunction void Init_distributions(){

	// Find Gradients and normals:
	real_t myPhaseF = PhaseF(0,0);

	vector_t gradPhi = calcGradPhi();
	real_t nx, ny;
	// gradPhi.z stores the magnitude of the vector
	nx = gradPhi.x/gradPhi.z;
	ny = gradPhi.y/gradPhi.z;

	// Define Equilibrium, then initialise all da things
	U = VelocityX;
	V = VelocityY;
	real_t mag = U*U + V*V;

	real_t Gamma[9], F_phi[9];
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
	real_t tmp1 = (1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/W;

	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, U, V, mag);
		F_phi[i] = calcF_phi(i, tmp1, nx, ny);
		h[i] = myPhaseF * Gamma[i] - 0.5*F_phi[i];   // heq
		g[i] = Gamma[i] - wf[i]; 				     //geq
	}

	#ifdef OPTIONS_RT
		PhaseOld = myPhaseF;
	#endif
	
	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Convective_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_N){
			<?R if (Options$Outflow){
				C(g_old, g)	
				C(h_old, h)	}	?>
		}
	#endif
	PhaseF = <?R C(sum(h)) ?>;
}

//	ITERATION:
CudaDeviceFunction void BC_Switcher ()
{
	switch (NodeType & NODE_BOUNDARY) {
		case NODE_Solid:
		case NODE_Wall:
			BounceBack();
			break;
		case NODE_MovingWall_N:
			MovingWall_N_Dirichlet();
			break;
		case NODE_MovingWall_S:
			MovingWall_S_Dirichlet();
			break;
		case NODE_NVelocity:
			NVelocity();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;
		case NODE_EOutflow_ML:
			Outflow_East_ML();
			break;

	#ifdef OPTIONS_Outflow
		case NODE_Convective_E:
			EConvective();
			break;
		case NODE_Convective_N:
			NConvective();
			break;
		case NODE_Neumann_E:
			ENeumann();
			break;
	#endif
	}
}

CudaDeviceFunction void calcHydroIter() {
	real_t tmpPhase = 0.0;
	if ((NodeType & NODE_ADDITIONALS) == NODE_Smoothing){
		Init_distributions();
	}
	else{
		PhaseF = PhaseF(0,0);
		tmpPhase = PhaseF;
		real_t myPhaseF = PhaseF;
		real_t rho = calcRho(myPhaseF);
		log_data_from_special_nodes();
		#ifdef OPTIONS_debug	
			AddToMomentumX(U*rho);
			AddToMomentumY(V*rho);
		#endif

		BC_Switcher();		

                if (PhaseF <= 0.5) {
//			AddToBubbleVelocityX( (1 - PhaseF)*U );
//			AddToBubbleVelocityY( (1 - PhaseF)*V );
			AddToBubbleLocationY( (1 - PhaseF)*Y );
			AddToSumPhiGas( (1 - PhaseF) );
		}
		#ifdef OPTIONS_BGK
			if (NodeType & NODE_BGK) { CollisionBGK();}
		#elif OPTIONS_CM
			if (NodeType & NODE_CM) { CollisionCM();}
		#else
			if (NodeType & NODE_MRT) { CollisionMRT();}
		#endif
                if (tmpPhase <= 0.5) {
			AddToBubbleVelocityX( (1 - tmpPhase)*U );
			AddToBubbleVelocityY( (1 - tmpPhase)*V );
		}

		myPhaseF = PhaseF(0,0);
		rho = calcRho(myPhaseF);
	
		#ifdef OPTIONS_debug
			AddToMomentumX_afterCol(U*rho);
			AddToMomentumY_afterCol(V*rho);
		#endif
	}
}

CudaDeviceFunction void log_data_from_special_nodes ()
{	
	switch (NodeType & NODE_ADDITIONALS) {
		real_t location;
		case NODE_SpikeTrack:
			if (PhaseF < 0.5 && PhaseF(0,1) > 0.5 ) {
				location =4.0*Period - (Y + (PhaseF-0.5)/(PhaseF-PhaseF(0,1) ));
				AddToRTISpike(location);
			}
		case NODE_BubbleTrack:
			if (PhaseF < 0.5 && PhaseF(0,1) > 0.5) {
				location = Y + (PhaseF-0.5)/(PhaseF-PhaseF(0,1) );
				AddToRTIBubble(location);
			}
	}
}

CudaDeviceFunction void calcPhaseFIter(){
	#ifdef OPTIONS_RT
		PhaseOld = PhaseF(0,0);
	#endif
	
	BC_Switcher(); 

	// eq 12 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"	
	PhaseF = <?R C(sum(h)) ?>;
}

CudaDeviceFunction void calcWallPhaseIter(){
// Contact angle is defined with respect to the high density fluid
	PhaseF = PhaseF(0,0);

	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) {
		if (nw_x == 0 && nw_y == 0) { 
			PhaseF = 0.0; // TODO: why not simply PhaseF = PhaseF(0,0);
			return;
		} 
		real_t myA, myH, myPhase;

		myPhase = PhaseF_dyn(nw_x, nw_y);
		myH = sqrt(nw_x*nw_x + nw_y*nw_y );

		if (fabs(radAngle - PI/2) < 1e-4) { PhaseF = myPhase; } 
		else {   
			myA = 1.0 - 0.5*myH * (4.0/W)  * cos( radAngle );
			PhaseF = (myA - sqrt( myA*myA - 4.0 * (myA-1.0)*myPhase))/(myA-1.0) - myPhase;
		}
	} 	 
}

#ifdef OPTIONS_CM
	CudaDeviceFunction void relax_CM_hydro(real_t f_in[9], real_t tau, vector_t u)
	{
		real_t uxuy = u.x*u.y;
		real_t ux2 = u.x*u.x;
		real_t uy2 = u.y*u.y;
		
		real_t s_v = 1./tau;
		real_t s_b = omega_bulk;
		
		real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];
		
		real_t temp[9]; real_t cm_eq[9];
		for (int i = 0; i < 9; i++) {
			temp[i] = f_in[i];}
		
		//raw moments from density-probability functions
		//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
		f_in[0] = m00;
		f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
		f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
		f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
		f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
		f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
		f_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
		f_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
		f_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
		
		//central moments from raw moments
		temp[0] = f_in[0];
		temp[1] = -f_in[0]*u.x + f_in[1];
		temp[2] = -f_in[0]*u.y + f_in[2];
		temp[3] = f_in[0]*ux2 - 2*f_in[1]*u.x + f_in[3];
		temp[4] = f_in[0]*uy2 - 2*f_in[2]*u.y + f_in[4];
		temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];
		temp[6] = -f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 - f_in[3]*u.y - 2*f_in[5]*u.x + f_in[6];
		temp[7] = -f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy - f_in[4]*u.x - 2*f_in[5]*u.y + f_in[7];
		temp[8] = f_in[0]*ux2*uy2 - 2*f_in[1]*u.x*uy2 - 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy - 2*f_in[6]*u.y - 2*f_in[7]*u.x + f_in[8];
		
		//collision in central moments space
		//calculate equilibrium distributions in cm space
		cm_eq[0] = m00;
		cm_eq[1] = -u.x*(m00 - 1.0);
		cm_eq[2] = -u.y*(m00 - 1.0);
		cm_eq[3] = m00*ux2 + 1./3.*m00 - ux2;
		cm_eq[4] = m00*uy2 + 1./3.*m00 - uy2;
		cm_eq[5] = uxuy*(m00 - 1.0);
		cm_eq[6] = -u.y*(m00*ux2 + 1./3.*m00 - ux2 - 1./3.);
		cm_eq[7] = -u.x*(m00*uy2 + 1./3.*m00 - uy2 - 1./3.);
		cm_eq[8] = m00*ux2*uy2 + 1./3.*m00*ux2 + 1./3.*m00*uy2 + 1./9.*m00 - ux2*uy2 - 1./3.*ux2 - 1./3.*uy2;
		//collide eq: -S*(cm - cm_eq)
		f_in[0] = cm_eq[0] - temp[0];
		f_in[1] = cm_eq[1] - temp[1];
		f_in[2] = cm_eq[2] - temp[2];
		f_in[3] = 0.5*(cm_eq[3] - temp[3])*(s_b + s_v) + 0.5*(cm_eq[4] - temp[4])*(s_b - s_v);
		f_in[4] = 0.5*(cm_eq[3] - temp[3])*(s_b - s_v) + 0.5*(cm_eq[4] - temp[4])*(s_b + s_v);
		f_in[5] = s_v*(cm_eq[5] - temp[5]);
		f_in[6] = cm_eq[6] - temp[6];
		f_in[7] = cm_eq[7] - temp[7];
		f_in[8] = cm_eq[8] - temp[8];
		
		//back to raw moments
		temp[0] = f_in[0];
		temp[1] = f_in[0]*u.x + f_in[1];
		temp[2] = f_in[0]*u.y + f_in[2];
		temp[3] = f_in[0]*ux2 + 2*f_in[1]*u.x + f_in[3];
		temp[4] = f_in[0]*uy2 + 2*f_in[2]*u.y + f_in[4];
		temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
		temp[6] = f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2*f_in[5]*u.x + f_in[6];
		temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy + f_in[4]*u.x + 2*f_in[5]*u.y + f_in[7];
		temp[8] = f_in[0]*ux2*uy2 + 2*f_in[1]*u.x*uy2 + 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy + 2*f_in[6]*u.y + 2*f_in[7]*u.x + f_in[8];
		
		//back to density-probability functions
		f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
		f_in[1] = temp[1]/2 + temp[3]/2 - temp[7]/2 - temp[8]/2;
		f_in[2] = temp[2]/2 + temp[4]/2 - temp[6]/2 - temp[8]/2;
		f_in[3] = -temp[1]/2 + temp[3]/2 + temp[7]/2 - temp[8]/2;
		f_in[4] = -temp[2]/2 + temp[4]/2 + temp[6]/2 - temp[8]/2;
		f_in[5] = temp[5]/4 + temp[6]/4 + temp[7]/4 + temp[8]/4;
		f_in[6] = -temp[5]/4 + temp[6]/4 - temp[7]/4 + temp[8]/4;
		f_in[7] = temp[5]/4 - temp[6]/4 - temp[7]/4 + temp[8]/4;
		f_in[8] = -temp[5]/4 - temp[6]/4 + temp[7]/4 + temp[8]/4;
	}

	CudaDeviceFunction void relax_and_collide_CM_hydro(real_t f_in[9], real_t tau, vector_t u, vector_t Fhydro, real_t rho) 
	{
		real_t uxuy = u.x*u.y;
		real_t ux2 = u.x*u.x;
		real_t uy2 = u.y*u.y;

		real_t s_v = 1./tau;
		real_t s_b = omega_bulk;
		real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];
		real_t temp[9]; real_t cm_eq[9];
		for (int i = 0; i < 9; i++) {
			temp[i] = f_in[i];}
		//raw moments from density-probability functions
		//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
		f_in[0] = m00;
		f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
		f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
		f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
		f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
		f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
		//central moments from raw moments
		temp[3] = f_in[0]*ux2 - 2.0*f_in[1]*u.x + f_in[3];
		temp[4] = f_in[0]*uy2 - 2.0*f_in[2]*u.y + f_in[4];
		temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];	
		//collision in central moments space
		//calculate equilibrium distributions in cm space
		cm_eq[0] = m00;
		cm_eq[1] = -u.x*(m00 - 1.0);
		cm_eq[2] = -u.y*(m00 - 1.0);
		cm_eq[3] = m00*ux2 + 1./3.*m00 - ux2;
		cm_eq[4] = m00*uy2 + 1./3.*m00 - uy2;
		cm_eq[5] = uxuy*(m00 - 1.0);
		cm_eq[6] = -u.y*(m00*ux2 + 1./3.*m00 - ux2 - 1./3.);
		cm_eq[7] = -u.x*(m00*uy2 + 1./3.*m00 - uy2 - 1./3.);
		cm_eq[8] = m00*ux2*uy2 + 1./3.*m00*ux2 + 1./3.*m00*uy2 + 1./9.*m00 - ux2*uy2 - 1./3.*ux2 - 1./3.*uy2;

		//calculate forces in cm space
		//He et al. scheme: get_continuous_Maxwellian_DF(dzeta=dzeta, psi=1, u=(ux, uy)) - velocity term
		//collide eq: (eye(9)-S)*cm + S*cm_eq + (eye(9)-S/2.)*force_in_cm_space // SOI
		f_in[0] = cm_eq[0];
		f_in[1] = 0.5*Fhydro.x/rho + cm_eq[1];
		f_in[2] = 0.5*Fhydro.y/rho + cm_eq[2];
		f_in[3] = 0.5*cm_eq[3]*(s_b + s_v) + 0.5*cm_eq[4]*(s_b - s_v) - temp[3]*(0.5*s_b + 0.5*s_v - 1.0) - 0.5*temp[4]*(s_b - s_v);
		f_in[4] = 0.5*cm_eq[3]*(s_b - s_v) + 0.5*cm_eq[4]*(s_b + s_v) - 0.5*temp[3]*(s_b - s_v) - temp[4]*(0.5*s_b + 0.5*s_v - 1.0);
		f_in[5] = cm_eq[5]*s_v - temp[5]*(s_v - 1.0);
		f_in[6] = 1./6.*Fhydro.y/rho + cm_eq[6];
		f_in[7] = 1./6.*Fhydro.x/rho + cm_eq[7];
		f_in[8] = cm_eq[8];

		//back to raw moments
		temp[0] = f_in[0];
		temp[1] = f_in[0]*u.x + f_in[1];
		temp[2] = f_in[0]*u.y + f_in[2];
		temp[3] = f_in[0]*ux2 + 2.0*f_in[1]*u.x + f_in[3];
		temp[4] = f_in[0]*uy2 + 2.0*f_in[2]*u.y + f_in[4];
		temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
		temp[6] = f_in[0]*ux2*u.y + 2.0*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2.0*f_in[5]*u.x + f_in[6];
		temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2.0*f_in[2]*uxuy + f_in[4]*u.x + 2.0*f_in[5]*u.y + f_in[7];
		temp[8] = f_in[0]*ux2*uy2 + 2.0*f_in[1]*u.x*uy2 + 2.0*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4.0*f_in[5]*uxuy + 2.0*f_in[6]*u.y + 2.0*f_in[7]*u.x + f_in[8];
		//back to density-probability functions
		f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
		f_in[1] = 0.5*temp[1] + 0.5*temp[3] - 0.5*temp[7] - 0.5*temp[8];
		f_in[2] = 0.5*temp[2] + 0.5*temp[4] - 0.5*temp[6] - 0.5*temp[8];
		f_in[3] = -0.5*temp[1] + 0.5*temp[3] + 0.5*temp[7] - 0.5*temp[8];
		f_in[4] = -0.5*temp[2] + 0.5*temp[4] + 0.5*temp[6] - 0.5*temp[8];
		f_in[5] = 0.25*temp[5] + 0.25*temp[6] + 0.25*temp[7] + 0.25*temp[8];
		f_in[6] = -0.25*temp[5] + 0.25*temp[6] - 0.25*temp[7] + 0.25*temp[8];
		f_in[7] = 0.25*temp[5] - 0.25*temp[6] - 0.25*temp[7] + 0.25*temp[8];
		f_in[8] = -0.25*temp[5] - 0.25*temp[6] + 0.25*temp[7] + 0.25*temp[8];
	}

	CudaDeviceFunction void relax_and_collide_CM_phase_field(real_t f_in[9], real_t tau, vector_t u, vector_t F_phi, real_t rho) 
	{
		real_t uxuy = u.x*u.y;
		real_t ux2 = u.x*u.x;
		real_t uy2 = u.y*u.y;

		real_t s_v = 1./tau;
		real_t s_b = omega_bulk;

		real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];

		real_t temp[9];

		for (int i = 0; i < 9; i++) {
			temp[i] = f_in[i];}

		//raw moments from density-probability functions
		//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
		f_in[0] = m00;
		f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
		f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];

		// f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
		// f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
		// f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
		// f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
		// f_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
		// f_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
		// f_in[8] = temp[5] + temp[6] + temp[7] + temp[8];

		// Central moments from raw moments
		// temp[0] = m00;
		temp[1] = -f_in[0]*u.x + f_in[1];
		temp[2] = -f_in[0]*u.y + f_in[2];

		// temp[3] = f_in[0]*ux2 - 2*f_in[1]*u.x + f_in[3];
		// temp[4] = f_in[0]*uy2 - 2*f_in[2]*u.y + f_in[4];
		// temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];
		// temp[6] = -f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 - f_in[3]*u.y - 2*f_in[5]*u.x + f_in[6];
		// temp[7] = -f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy - f_in[4]*u.x - 2*f_in[5]*u.y + f_in[7];
		// temp[8] = f_in[0]*ux2*uy2 - 2*f_in[1]*u.x*uy2 - 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy - 2*f_in[6]*u.y - 2*f_in[7]*u.x + f_in[8];

		// Collision in central moments space
		// Default is second order integration (trapezoidal discretization)
		// collide eq: (eye(9)-S)*cm + S*cm_eq + (eye(9)-S/2.)*F_phi_cm
		// relax 1st moments
		f_in[0] = m00;
		f_in[1] = -F_phi.x*(0.5*s_v - 1.0) - temp[1]*(s_v - 1.0);
		f_in[2] = -F_phi.y*(0.5*s_v - 1.0) - temp[2]*(s_v - 1.0);
		f_in[3] = 1./3.*m00;
		f_in[4] = 1./3.*m00;
		f_in[5] = 0;
		f_in[6] = 1./6.*F_phi.y;
		f_in[7] = 1./6.*F_phi.x;
		f_in[8] = 1./9.*m00;

		//back to raw moments
		temp[0] = f_in[0];
		temp[1] = f_in[0]*u.x + f_in[1];
		temp[2] = f_in[0]*u.y + f_in[2];
		temp[3] = f_in[0]*ux2 + 2*f_in[1]*u.x + f_in[3];
		temp[4] = f_in[0]*uy2 + 2*f_in[2]*u.y + f_in[4];
		temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
		temp[6] = f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2*f_in[5]*u.x + f_in[6];
		temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy + f_in[4]*u.x + 2*f_in[5]*u.y + f_in[7];
		temp[8] = f_in[0]*ux2*uy2 + 2*f_in[1]*u.x*uy2 + 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy + 2*f_in[6]*u.y + 2*f_in[7]*u.x + f_in[8];

		//back to density-probability functions
		f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
		f_in[1] = temp[1]/2 + temp[3]/2 - temp[7]/2 - temp[8]/2;
		f_in[2] = temp[2]/2 + temp[4]/2 - temp[6]/2 - temp[8]/2;
		f_in[3] = -temp[1]/2 + temp[3]/2 + temp[7]/2 - temp[8]/2;
		f_in[4] = -temp[2]/2 + temp[4]/2 + temp[6]/2 - temp[8]/2;
		f_in[5] = temp[5]/4 + temp[6]/4 + temp[7]/4 + temp[8]/4;
		f_in[6] = -temp[5]/4 + temp[6]/4 - temp[7]/4 + temp[8]/4;
		f_in[7] = temp[5]/4 - temp[6]/4 - temp[7]/4 + temp[8]/4;
		f_in[8] = -temp[5]/4 - temp[6]/4 + temp[7]/4 + temp[8]/4;
	}

	CudaDeviceFunction vector_t calcTotalHydrodynamicForceCM(vector_t gradPhi, real_t myPhaseF, real_t rho, real_t tau, real_t mu, real_t p)
	{
		// arguments:
		// gradPhi - Phase field gradients
		// myPhaseF - PhaseField value at cell of interest (0,0 or BC like inlet_PhaseF, moving_wall_PhaseF)

		// Fluid Properties: //
		// real_t rho - fluid density
		// real_t tau - relaxation parameter
		// real_t mu - chemical potential 
		// real_t p - normalized pressure

		real_t Gamma[9], geq[9], mag;	// equilibrium, pressure equilibrium, velocity magnitude
		real_t F_pressure[2], F_body[2], F_mu[2], F_surf_tension[2];   // Forces
		vector_t F_total_hydro;	

		real_t stress[3];				// Stress tensor calculation
		real_t R[9];				// Populations for MRT relaxation

		// Force Calculations
		// eq 19
		real_t density_coeff = (Density_h-Density_l)/(PhaseField_h-PhaseField_l);
		F_pressure[0] = (-1.0/3.0) * p * density_coeff * gradPhi.x;
		F_pressure[1] = (-1.0/3.0) * p * density_coeff * gradPhi.y;	

		F_body[0] = -1.0*(rho-Density_l)*BuoyancyX + rho*GravitationX;
		F_body[1] = -1.0*(rho-Density_l)*BuoyancyY + rho*GravitationY;
		
		// eq 4
		F_surf_tension[0] = mu*gradPhi.x;
		F_surf_tension[1] = mu*gradPhi.y;

		// Calculate viscous force
		for (int j=0;j<fixedIterator;j++){
			// User has the choice in attempt to improve stability to use
			// a fixed point iteration style update for the viscous force.
			for (int i=0; i< 9; i++){
				R[i] = g[i];
			}
			
			vector_t u;
			u.x = U;
			u.y = V;
			relax_CM_hydro(R, tau, u); 

			// Stress/strain Tensor
			stress[0] = 0.0;stress[1] = 0.0;stress[2] = 0.0;
			for (int i=0; i< 9; i++){
				stress[0] -= R[i]*d2q9_ex[i]*d2q9_ex[i];
				stress[1] -= R[i]*d2q9_ex[i]*d2q9_ey[i];
				stress[2] -= R[i]*d2q9_ey[i]*d2q9_ey[i];    
			}
			
			// Viscous force
			F_mu[0] = (0.5-tau) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y) * density_coeff;
			F_mu[1] = (0.5-tau) * (stress[1]*gradPhi.x + stress[2]*gradPhi.y) * density_coeff;

			// Total Hydrodynamic Force
			F_total_hydro.x = F_surf_tension[0] + F_pressure[0] + F_body[0] + F_mu[0];
			F_total_hydro.y = F_surf_tension[1] + F_pressure[1] + F_body[1] + F_mu[1];
			F_total_hydro.z = 0;

			// update velocity and re-iterate
			U = g[1]-g[3]+g[5]-g[6]-g[7]+g[8];
			V = g[2]-g[4]+g[5]+g[6]-g[7]-g[8];

			U += 0.5*F_total_hydro.x/rho;
			V += 0.5*F_total_hydro.y/rho;
		}
		#ifdef OPTIONS_debug
			AddToF_pressureX(F_pressure[0]);
			AddToF_pressureY(F_pressure[1]);
			AddToF_bodyX(F_body[0]);
			AddToF_bodyY(F_body[1]);
			AddToF_surf_tensionX(F_surf_tension[0]);
			AddToF_surf_tensionY(F_surf_tension[1]);
			AddToF_muX(F_mu[0]);
			AddToF_muY(F_mu[1]);
			AddToF_total_hydroX(F_total_hydro.x);
			AddToF_total_hydroY(F_total_hydro.y);
		#endif

		return F_total_hydro;
	}

	CudaDeviceFunction void CollisionCM(){
		#ifdef OPTIONS_RT
			real_t uold = U;
			real_t vold = V;
		#endif

		real_t myPhaseF = PhaseF(0,0);

		// Find Macroscopic Details
		real_t rho = calcRho(myPhaseF);
		real_t tau = calcTau(myPhaseF, rho);
		real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);

		// Gradients & Normals
		vector_t gradPhi = calcGradPhi(); // Phase field gradient
		real_t p = getNormalizedPressure(); // normalized pressure

		vector_t Fhydro = calcTotalHydrodynamicForceCM(gradPhi, myPhaseF, rho, tau,  calcMu(myPhaseF), p);

		// PHASE FIELD POPULATION UPDATE:
		vector_t u; u.x = U; u.y = V;
		vector_t F_phi_vect = calcF_phi_xy(gradPhi,  myPhaseF,  pfavg);
		#ifdef OPTIONS_debug
			AddToF_phiX(F_phi_vect.x);
			AddToF_phiY(F_phi_vect.y);
		#endif
		relax_and_collide_CM_phase_field(h, 1./omega_phi, u, F_phi_vect, rho);
		
		// PRESSURE EVOLUTION UPDATE:
		relax_and_collide_CM_hydro(g, tau, u, Fhydro, rho);
	}
#elif OPTIONS_BGK
	CudaDeviceFunction void CollisionBGK(){
		int i, j;
		real_t C = PhaseF(0,0), mu;
		real_t tau, DynVisc, rho, p;		// Macroscopic Properties
		vector_t gradPhi;					// Phase field gradients
		real_t nx, ny;						// Normals
		real_t Gamma[9], geq[9], mag;		// equilibrium, pressure equilibrium, velocity magnitude
		real_t F_pressure[2], F_body[2], F_mu[2], F_total[2]; // Forces
		real_t tmp1, stress[3];				// Stress tensor calculation
		real_t F_phi[9], heq[9];			// Phase field collision terms
		real_t F_i[9];						// Momentum distribution forcing term

		// Find Macroscopic Details
		mu = calcMu( C );
		rho = Density_l + (C - PhaseField_l)*(Density_h - Density_l);
		p = g[0]+g[1]+g[2]+g[3]+g[4]+g[5]+g[6]+g[7]+g[8];

		// Updating of tau:
		//    Updating via the kinematic viscosity here gives more stable solutions
		//    Updating via the dynVisc section of the code is more accurate
		//        but will go unstable for low viscosities
		if ( C < PhaseField_l){
			tau = tau_l + 0.5;
		} else if (C > PhaseField_h) {
			tau = tau_h + 0.5;
		} else {
			// Inverse update:
			//tau = (C - PhaseField_l)/(PhaseField_h - PhaseField_l) * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
			//tau = 1.0/tau + 0.5;
			// Linear update:
			tau = 0.5 + tau_l + C*(tau_h - tau_l);
			// Viscosity update:
			//DynVisc = Density_l*Viscosity_l + C * (Density_h*Viscosity_h - Density_l*Viscosity_l);
			//tau = 3.0 * DynVisc / rho + 0.5;
		}

		// GRADIENTS AND NORMALS
		gradPhi = calcGradPhi();
		nx = gradPhi.x/gradPhi.z;
		ny = gradPhi.y/gradPhi.z;

		// CALCULATE FORCES:
		real_t density_coeff = (Density_h-Density_l)/(PhaseField_h-PhaseField_l);
		F_pressure[0] = (-1.0/3.0) * p * density_coeff * gradPhi.x;
		F_pressure[1] = (-1.0/3.0) * p * density_coeff * gradPhi.y;
		F_body[0] = -1.0*(rho-Density_l)*BuoyancyX + rho*GravitationX;
		F_body[1] = -1.0*(rho-Density_l)*BuoyancyY + rho*GravitationY;

		// Finding viscous force:
		for (j=0;j<fixedIterator;j++) {
			// GAMMA AND EQUILIBRIUM
			mag = U*U + V*V;
			for (i=0; i< 9; i++){
				Gamma[i] = calcGamma(i, U, V, mag);
				geq[i] = wf[i]*p + Gamma[i] - wf[i];
			}

				// Stress/strain Tensor
			stress[0] = 0.0;stress[1] = 0.0;stress[2] = 0.0;
			for (i=0; i< 9; i++){
				tmp1 = g[i] - geq[i];
				stress[0] += tmp1*d2q9_ex[i]*d2q9_ex[i];
				stress[1] += tmp1*d2q9_ex[i]*d2q9_ey[i];
				stress[2] += tmp1*d2q9_ey[i]*d2q9_ey[i];    }

			F_mu[0] = (0.5-tau)/tau * (stress[0]*gradPhi.x + stress[1]*gradPhi.y) * density_coeff;
			F_mu[1] = (0.5-tau)/tau * (stress[1]*gradPhi.x + stress[2]*gradPhi.y) * density_coeff;
			F_total[0] = mu*gradPhi.x + F_pressure[0] + F_body[0] + F_mu[0];
			F_total[1] = mu*gradPhi.y + F_pressure[1] + F_body[1] + F_mu[1];
			U = g[1]-g[3]+g[5]-g[6]-g[7]+g[8] + 0.5*F_total[0]/rho;
			V = g[2]-g[4]+g[5]+g[6]-g[7]-g[8] + 0.5*F_total[1]/rho;
		}
		// PHASE FIELD POPULATION UPDATE:

		real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
		tmp1 = (1.0 - 4.0*(C - pfavg)*(C - pfavg))/W;
		for (i=0; i< 9; i++){
			F_phi[i] = calcF_phi(i, tmp1, nx, ny); // Forcing Terms
			heq[i] = C * Gamma[i] - 0.5*F_phi[i];  // heq
			h[i] = h[i] - omega_phi * (h[i]-heq[i]) + F_phi[i];	// collision
		}
		// PRESSURE EVOLUTION UPDATE:
		for (i=0; i< 9; i++) {
			F_i[i] = 3.0*wf[i] * (F_total[0]*d2q9_ex[i] + F_total[1]*d2q9_ey[i])/rho;
			g[i] = g[i]-(g[i]-(geq[i]-0.5*F_i[i]))/tau+F_i[i];
		}
	}
#else
CudaDeviceFunction void relaxMRT(real_t R[9], real_t tau)
{
	real_t S[9]; // Populations for MRT relaxation
		
	// the cofficients (before R[i]) follows from the GramSchmidt transformation matrix:
	// eq 10.30 from The Lattice Boltzmann Method: Principles and Practice
	// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
	S[0] = R[8] + R[7] + R[6] + R[5] + R[4] + R[3] + R[2] + R[1] + R[0]; 			// density - m00
	S[1] = -R[4] - R[3] - R[2] - R[1] + ( R[8] + R[7] + R[6] + R[5] - R[0]*2. )*2.; // energy
	S[2] = R[8] + R[7] + R[6] + R[5] + ( -R[4] - R[3] - R[2] - R[1] + R[0]*2. )*2.; // energy^2
	S[3] = R[8] - R[7] - R[6] + R[5] - R[3] + R[1]; 		// x momentum flux - m10 
	S[4] = R[8] - R[7] - R[6] + R[5] + ( R[3] - R[1] )*2.;  // x energy flux
	S[5] = -R[8] - R[7] + R[6] + R[5] - R[4] + R[2];        // y momentum flux - m01
	S[6] = -R[8] - R[7] + R[6] + R[5] + ( R[4] - R[2] )*2.; // y energy flux
	S[7] = -R[4] + R[3] - R[2] + R[1]; // stress tensor xx (diagonal)
	S[8] = -R[8] + R[7] - R[6] + R[5]; // stress tensor xy (off-diagonal) - m11
	// Relax in Momentum space:
	// eq 10.34 - nonzero terms from the diagonal GramSchmidt relaxation matrix
	S[7] *= 1.0/(tau);
	S[8] *= 1.0/(tau);
	//Transform to back to shifted-Pressure space:
	// the cofficients (before S[i]) follows from the inverted GramSchmidt transformation matrix:
	// eq 10.33 from The Lattice Boltzmann Method: Principles and Practice
	R[0] = ( S[2] - S[1] + S[0] )/9.;
	R[1] = ( -S[1] + S[7]*9. + ( -S[2] + S[0]*2. + ( -S[4] + S[3] )*3. )*2. )/36.;
	R[2] = ( -S[1] - S[7]*9. + ( -S[2] + S[0]*2. + ( -S[6] + S[5] )*3. )*2. )/36.;
	R[3] = ( -S[1] + S[7]*9. + ( -S[2] + S[0]*2. + ( S[4] - S[3] )*3. )*2. )/36.;
	R[4] = ( -S[1] - S[7]*9. + ( -S[2] + S[0]*2. + ( S[6] - S[5] )*3. )*2. )/36.;
	R[5] = ( S[2] + ( S[1] + S[0]*2. )*2. + ( S[6] + S[4] + S[8]*3. + ( S[5] + S[3] )*2. )*3. )/36.;
	R[6] = ( S[2] + ( S[1] + S[0]*2. )*2. + ( S[6] - S[4] - S[8]*3. + ( S[5] - S[3] )*2. )*3. )/36.;
	R[7] = ( S[2] + ( S[1] + S[0]*2. )*2. + ( -S[6] - S[4] + S[8]*3. + ( -S[5] - S[3] )*2. )*3. )/36.;
	R[8] = ( S[2] + ( S[1] + S[0]*2. )*2. + ( -S[6] + S[4] - S[8]*3. + ( -S[5] + S[3] )*2. )*3. )/36.;
}

CudaDeviceFunction vector_t calcTotalHydrodynamicForceMRT(vector_t gradPhi, real_t myPhaseF, real_t rho, real_t tau, real_t mu, real_t p)
{
	// arguments:
	// gradPhi - Phase field gradients
	// myPhaseF - PhaseField value at cell of interest (0,0 or BC like inlet_PhaseF, moving_wall_PhaseF)

	// Fluid Properties: 
	// real_t rho - fluid density
	// real_t tau - relaxation parameter
	// real_t mu - chemical potential 
	// real_t p - normalized pressure

	real_t Gamma[9], geq[9], mag;	// equilibrium, pressure equilibrium, velocity magnitude
	real_t F_pressure[2], F_body[2], F_mu[2], F_surf_tension[2];   // Forces
	vector_t F_total_hydro;	

	real_t stress[3];			// Stress tensor calculation
	real_t R[9];				// Populations for MRT relaxation

	// Force Calculations
	// eq 19
	real_t density_coeff = (Density_h-Density_l)/(PhaseField_h-PhaseField_l);
	F_pressure[0] = (-1.0/3.0) * p * density_coeff * gradPhi.x;
	F_pressure[1] = (-1.0/3.0) * p * density_coeff * gradPhi.y;

	F_body[0] = -1.0*(rho-Density_l)*BuoyancyX + rho*GravitationX;
	F_body[1] = -1.0*(rho-Density_l)*BuoyancyY + rho*GravitationY;
	
	// eq 4
	F_surf_tension[0] = mu*gradPhi.x;
	F_surf_tension[1] = mu*gradPhi.y;

	// Calculate viscous force
	for (int j=0;j<fixedIterator;j++){
		// Optional fixed point iterator
		// 	MRT stuff
		mag = U*U + V*V;
		for (int i=0; i< 9; i++){
			Gamma[i] = calcGamma(i, U, V, mag);
			geq[i] = wf[i]*p + Gamma[i] - wf[i]; 
			R[i] = g[i] - geq[i];
		}
		
		relaxMRT(R, tau);

		// Stress/strain Tensor
		stress[0] = 0.0;stress[1] = 0.0;stress[2] = 0.0;
		for (int i=0; i< 9; i++){
			stress[0] += R[i]*d2q9_ex[i]*d2q9_ex[i];
			stress[1] += R[i]*d2q9_ex[i]*d2q9_ey[i];
			stress[2] += R[i]*d2q9_ey[i]*d2q9_ey[i];    
		}
		
		// Viscous force
		F_mu[0] = (0.5-tau) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y) * density_coeff;
		F_mu[1] = (0.5-tau) * (stress[1]*gradPhi.x + stress[2]*gradPhi.y) * density_coeff;

		// Total Hydrodynamic Force
		F_total_hydro.x = F_surf_tension[0] + F_pressure[0] + F_body[0] + F_mu[0];
		F_total_hydro.y = F_surf_tension[1] + F_pressure[1] + F_body[1] + F_mu[1];
		F_total_hydro.z = 0;

		// update velocity and re-iterate
		U = g[1]-g[3]+g[5]-g[6]-g[7]+g[8] + 0.5*F_total_hydro.x/rho;
		V = g[2]-g[4]+g[5]+g[6]-g[7]-g[8] + 0.5*F_total_hydro.y/rho;
	}
	#ifdef OPTIONS_debug
		AddToF_pressureX(F_pressure[0]);
		AddToF_pressureY(F_pressure[1]);
		AddToF_bodyX(F_body[0]);
		AddToF_bodyY(F_body[1]);
		AddToF_surf_tensionX(F_surf_tension[0]);
		AddToF_surf_tensionY(F_surf_tension[1]);
		AddToF_muX(F_mu[0]);
		AddToF_muY(F_mu[1]);
		AddToF_total_hydroX(F_total_hydro.x);
		AddToF_total_hydroY(F_total_hydro.y);
	#endif

	return F_total_hydro;
}

CudaDeviceFunction void CollisionMRT(){
	#ifdef OPTIONS_RT
		real_t uold = U;
		real_t vold = V;
	#endif

	real_t myPhaseF = PhaseF(0,0);

	real_t F_phi[9], heq[9];		// Phase field collision terms
	real_t F_i[9];					// Momentum distribution forcing term
	real_t R[9];					// Populations for MRT relaxation

	// Find Macroscopic Details
	real_t rho = calcRho(myPhaseF);
	real_t tau = calcTau(myPhaseF, rho);
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);

	//  Gradients & Normals
	vector_t gradPhi = calcGradPhi(); // Phase field gradient
	real_t nx = gradPhi.x/gradPhi.z;  // GradPhi normalized in x, y direction
	real_t ny = gradPhi.y/gradPhi.z;

	real_t p = getNormalizedPressure(); // normlized pressure
	vector_t Fhydro = calcTotalHydrodynamicForceMRT(gradPhi, myPhaseF, rho, tau,  calcMu(myPhaseF), p);

	// PHASE FIELD POPULATION UPDATE:
	#ifdef OPTIONS_RT
		real_t Req[9];
	#endif

	real_t Gamma[9], geq[9]; 	// equilibrium
	real_t mag = U*U + V*V; 	// velocity magnitude
	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, U, V, mag);
		geq[i] = wf[i]*p + Gamma[i] - wf[i]; 
	}

	real_t tmp1 = (1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/W;
	for (int i=0; i< 9; i++){
		#ifdef OPTIONS_RT
			Req[i] = 3.0 * wf[i] * (d2q9_ex[i] * (myPhaseF*U - PhaseOld*uold)
				+ d2q9_ey[i] * (myPhaseF*V - PhaseOld*vold));
			F_phi[i] = calcF_phi(i, tmp1, nx, ny) + Req[i];
			heq[i] = myPhaseF * wf[i] * (1 + 3.0 * (d2q9_ex[i]*U + d2q9_ey[i]*V) ) - 0.5*F_phi[i];
		#else
			F_phi[i] = calcF_phi(i, tmp1, nx, ny); // Forcing Terms:
			//calcF_phi: F_phi[i] = wf[i] * tmp1 * (d2q9_ex[i]*nx + d2q9_ey[i]*ny);
			heq[i] = myPhaseF * Gamma[i] - 0.5*F_phi[i];  // heq
		#endif
		#ifdef OPTIONS_debug
			AddToF_phiX(F_phi[i]*d2q9_ex[i]);
			AddToF_phiY(F_phi[i]*d2q9_ey[i]);
		#endif
			h[i] = h[i] - omega_phi * (h[i]-heq[i]) + F_phi[i];	// collision
		}

	//  PRESSURE EVOLUTION UPDATE:
	// ---------------------- MRT ---------------------------
	#ifdef OPTIONS_GF
		real_t Falpha_x, Falpha_y; // FOR EXTENDED FORCE SCHEME
	#endif
	for (int i=0; i< 9; i++){
	#ifdef OPTIONS_GF
		Falpha_x = d2q9_ex[i] - U + 3.0 * d2q9_ex[i] * (d2q9_ex[i]*U + d2q9_ey[i]*V); //FOR EXTENDED FORCE SCHEME
		Falpha_y = d2q9_ey[i] - V + 3.0 * d2q9_ey[i] * (d2q9_ex[i]*U + d2q9_ey[i]*V); //FOR EXTENDED FORCE SCHEME
		F_i[i] = 3.0*wf[i] * (Falpha_x * Fhydro.x + Falpha_y * Fhydro.y )/rho;        //FOR EXTENDED FORCE SCHEME
	#else
		// eq 15 from "Improved locality of the phase-field lattice Boltzmann 
		//	model for immiscible fluids at high density ratios"
		F_i[i] = 3.0*wf[i] * (Fhydro.x*d2q9_ex[i] + Fhydro.y*d2q9_ey[i])/rho;
	#endif
		// eq 16 from "Improved locality of the phase-field lattice Boltzmann 
		// model for immiscible fluids at high density ratios"
		R[i] = g[i] - (geq[i] - 0.5*F_i[i]);
	}

	relaxMRT(R, tau);

	// Collision 
	for (int i=0; i< 9; i++) {
		g[i] = g[i]-R[i]+F_i[i];
	}
}
#endif

//	MISCELLANIOUS FUNCTIONS:
CudaDeviceFunction float2 Color() {
        float2 ret;
        //vector_t u = getU();
		//ret.x = sqrt(u.x*u.x + u.y*u.y);
		
        if (PhaseF(0,0) < 0.8){
                ret.y = 0;
        } else {
                ret.y = 1;
		}
		
		ret.x = sqrt(U*U+V*V);
		//ret.y =1;
        return ret;
}


//	BOUNDARY CONDITIONS:
CudaDeviceFunction void EVelocity(real_t ux, real_t uy, real_t phase)
{
    U = ux;
    V = uy;
<?R
        n = c(1,0)
        g = PV(DensityAll$name[DensityAll$group=="g"])
        U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy")])
        u = PV(c("U","V"))
        EQ = MRT_eq(U, PV(1), u)
        geq = EQ$feq
        bounce = Bounce(U)
        sel = as.vector( (U %*% n) < 0)

        sel2 = as.vector( ( U %*% n) == 0)  
        exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
        Unknowns = 1.0/max(colSums(U[sel2,]^2)) # should be 6 for q27, 4 for q15
        Nmat = t(U[sel,]) %*% U[sel,]

        C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - 0.5* (exM %*% solve(Nmat) %*% t(U))[sel])
    ?>
    <?R
        h = PV(DensityAll$name[DensityAll$group=="h"])
        U_PF = U
        pf = PV("phase")
        EQ_h = MRT_eq(U_PF,PV(1),u)
        n = c(-1,0)
        heq = pf * EQ_h$feq
        bounce = Bounce(U_PF)
        sel = as.vector( (U_PF %*% n) < 0)

        sel2 = as.vector( ( U_PF %*% n) == 0)   
        exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
        Unknowns = 1.0/sum(sel)

        C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
    ?>
}
CudaDeviceFunction void Outflow_East_ML()
{
// Python generated code
real_t m,neuron0_inter,neuron1_inter,neuron2_inter,neuron3_inter,neuron4_inter,neuron5_inter,neuron6_inter,neuron7_inter,neuron8_inter,neuron9_inter,neuron10_inter,neuron11_inter,neuron12_inter,neuron13_inter,neuron14_inter,neuron15_inter,neuron16_inter,neuron17_inter,neuron18_inter,neuron19_inter,neuron20_inter,neuron21_inter,neuron22_inter,neuron23_inter,neuron24_inter,neuron25_inter;
real_t t,neuron0_hidden1,neuron1_hidden1,neuron2_hidden1,neuron3_hidden1,neuron4_hidden1,neuron5_hidden1,neuron6_hidden1,neuron7_hidden1,neuron8_hidden1,neuron9_hidden1,neuron10_hidden1,neuron11_hidden1,neuron12_hidden1,neuron13_hidden1,neuron14_hidden1,neuron15_hidden1,neuron16_hidden1,neuron17_hidden1,neuron18_hidden1,neuron19_hidden1,neuron20_hidden1,neuron21_hidden1,neuron22_hidden1,neuron23_hidden1,neuron24_hidden1,neuron25_hidden1;
real_t g0_tmp, g1_tmp, g2_tmp, g3_tmp, g4_tmp, g5_tmp, g6_tmp, g7_tmp, g8_tmp, h0_tmp, h1_tmp, h2_tmp, h3_tmp, h4_tmp, h5_tmp, h6_tmp, h7_tmp, h8_tmp;
real_t C = PhaseF(-1,0);
real_t phase, ux, uy;

g0_tmp = g[0]*489.76322810 + -0.91003840;
g1_tmp = g[1]*451.00142613 + -0.21934961;
g2_tmp = g[2]*993.12451405 + -0.24332748;
g4_tmp = g[4]*1017.08663299 + -0.24597271;
g5_tmp = g[5]*1772.52270224 + -0.19745633;
g8_tmp = g[8]*1698.34432451 + -0.18918769;
h0_tmp = h[0]*2.24749849 + -0.00000045;
h1_tmp = h[1]*8.86570420 + -0.00000044;
h2_tmp = h[2]*8.98568716 + -0.00000045;
h4_tmp = h[4]*8.98597859 + -0.00000045;
h5_tmp = h[5]*35.46368853 + -0.00000044;
h8_tmp = h[8]*35.46130595 + -0.00000044;
C = C*0.99892641 + -0.00000045;
neuron0_inter=0.168418*C - 0.344814*g0_tmp - 0.410702*g1_tmp + 0.167428*g2_tmp - 0.00874475*g4_tmp - 0.0953145*g5_tmp + 0.0715577*g8_tmp + 0.479235*h0_tmp + 0.323361*h1_tmp + 0.483366*h2_tmp + 0.552797*h4_tmp + 0.602236*h5_tmp + 0.0801678*h8_tmp + 0.160802;
 neuron1_inter=0.0244597*C + 0.0577436*g0_tmp + 0.229845*g1_tmp + 0.215861*g2_tmp + 0.0237137*g4_tmp - 0.0157368*g5_tmp + 0.267942*g8_tmp + 0.460913*h0_tmp + 0.455765*h1_tmp + 0.106809*h2_tmp + 0.585902*h4_tmp - 0.0200136*h5_tmp + 0.215403*h8_tmp + 0.277446;
 neuron2_inter=0.568199*C + 0.00277414*g0_tmp + 0.472165*g1_tmp + 0.423021*g2_tmp + 0.280752*g4_tmp + 0.406786*g5_tmp + 0.369666*g8_tmp + 0.187228*h0_tmp + 0.397474*h1_tmp + 0.440933*h2_tmp + 0.11739*h4_tmp - 0.0353169*h5_tmp + 0.287214*h8_tmp + 0.305814;
 neuron3_inter=0.663687*C + 0.19171*g0_tmp - 0.313488*g1_tmp + 0.193286*g2_tmp + 0.510683*g4_tmp + 0.0767767*g5_tmp - 0.167794*g8_tmp + 0.0444628*h0_tmp + 0.225506*h1_tmp + 0.329913*h2_tmp + 0.00187413*h4_tmp + 0.629202*h5_tmp + 0.640279*h8_tmp + 0.288846;
 neuron4_inter=-0.0199494*C - 0.257276*g0_tmp - 0.280627*g1_tmp - 0.589203*g2_tmp - 0.163557*g4_tmp - 0.040333*g5_tmp - 0.0631628*g8_tmp - 0.486506*h0_tmp - 0.250933*h1_tmp - 0.346654*h2_tmp - 0.122433*h4_tmp - 0.412473*h5_tmp - 0.137719*h8_tmp - 0.130629;
 neuron5_inter=0.0784197*C + 0.498984*g0_tmp - 0.321596*g1_tmp - 1.70005*g2_tmp + 2.04776*g4_tmp - 1.08909*g5_tmp + 0.25082*g8_tmp + 0.101018*h0_tmp + 0.284428*h1_tmp - 0.15389*h2_tmp - 0.0791898*h4_tmp - 0.347782*h5_tmp + 0.169623*h8_tmp + 0.1483;
 neuron6_inter=-0.121247*C + 0.066622*g0_tmp - 0.696323*g1_tmp + 0.469436*g2_tmp + 0.201561*g4_tmp - 0.79874*g5_tmp - 0.808933*g8_tmp + 0.41131*h0_tmp - 0.0146543*h1_tmp + 0.260432*h2_tmp + 0.181805*h4_tmp + 0.214565*h5_tmp - 0.204819*h8_tmp + 0.0157942;
 neuron7_inter=0.0221193*C - 0.0428407*g0_tmp + 0.00734876*g1_tmp - 0.0345035*g2_tmp + 0.11325*g4_tmp + 0.470613*g5_tmp - 0.0090816*g8_tmp + 0.160574*h0_tmp + 0.0413716*h1_tmp + 0.510889*h2_tmp + 0.589043*h4_tmp + 0.242884*h5_tmp + 0.677598*h8_tmp + 0.276366;
 neuron8_inter=0.103172*C + 0.238835*g0_tmp - 1.08331*g1_tmp - 0.0235579*g2_tmp - 0.0892287*g4_tmp - 1.10622*g5_tmp - 0.966101*g8_tmp + 0.332977*h0_tmp + 0.0301981*h1_tmp - 0.284991*h2_tmp + 0.383184*h4_tmp - 0.143911*h5_tmp + 0.211533*h8_tmp + 0.0230805;
 neuron9_inter=0.513297*C + 0.176755*g0_tmp + 0.291146*g1_tmp - 0.411767*g2_tmp + 0.00648224*g4_tmp + 0.106912*g5_tmp + 0.579268*g8_tmp - 0.101006*h0_tmp + 0.172944*h1_tmp + 0.281179*h2_tmp + 0.663082*h4_tmp - 0.0450795*h5_tmp + 0.357138*h8_tmp + 0.164239;
 neuron10_inter=-0.160045*C + 0.218124*g0_tmp - 0.903107*g1_tmp + 0.343934*g2_tmp - 0.232957*g4_tmp - 0.173755*g5_tmp - 0.970292*g8_tmp - 0.238783*h0_tmp - 0.0627036*h1_tmp - 0.354869*h2_tmp - 0.245576*h4_tmp - 0.651452*h5_tmp - 0.654758*h8_tmp - 0.39044;
 neuron11_inter=-0.571258*C - 0.355011*g0_tmp - 0.887546*g1_tmp - 0.0945235*g2_tmp - 0.178592*g4_tmp - 0.545385*g5_tmp - 0.419226*g8_tmp - 0.255474*h0_tmp - 0.295313*h1_tmp - 0.718755*h2_tmp - 0.716204*h4_tmp - 0.167915*h5_tmp - 0.395905*h8_tmp - 0.175267;
 neuron12_inter=0.0796445*C - 0.218319*g0_tmp + 0.0746893*g1_tmp + 0.470665*g2_tmp - 0.430433*g4_tmp + 0.247235*g5_tmp - 0.0610046*g8_tmp - 0.00733265*h0_tmp + 0.623707*h1_tmp + 0.260271*h2_tmp + 0.537183*h4_tmp + 0.176747*h5_tmp + 0.594891*h8_tmp + 0.130436;
 neuron13_inter=0.415193*C + 0.22535*g0_tmp - 0.943405*g1_tmp + 0.585694*g2_tmp - 1.08601*g4_tmp + 0.175962*g5_tmp - 0.511109*g8_tmp - 0.0541312*h0_tmp - 0.276045*h1_tmp + 0.112702*h2_tmp - 0.451863*h4_tmp - 0.215443*h5_tmp + 0.17908*h8_tmp - 0.133472;
 neuron14_inter=-0.107373*C - 0.595659*g0_tmp - 0.123208*g1_tmp - 0.229895*g2_tmp - 0.83636*g4_tmp + 0.265929*g5_tmp - 0.427428*g8_tmp + 0.758432*h0_tmp + 0.229643*h1_tmp + 0.649645*h2_tmp + 0.510136*h4_tmp + 0.643105*h5_tmp + 0.683369*h8_tmp - 0.50083;
 neuron15_inter=-0.657165*C + 0.811461*g0_tmp - 0.0209292*g1_tmp + 0.116233*g2_tmp + 0.52252*g4_tmp - 0.366731*g5_tmp - 0.0364099*g8_tmp - 0.304037*h0_tmp - 0.153961*h1_tmp - 0.375539*h2_tmp - 0.557562*h4_tmp - 0.551748*h5_tmp - 0.0107577*h8_tmp - 0.00879124;
 neuron16_inter=0.32373*C + 0.134212*g0_tmp - 1.07078*g1_tmp + 0.0557133*g2_tmp + 0.845636*g4_tmp - 1.12806*g5_tmp - 0.91784*g8_tmp - 0.161624*h0_tmp - 0.0281037*h1_tmp + 0.156905*h2_tmp - 0.0220845*h4_tmp - 0.0286336*h5_tmp + 0.220972*h8_tmp + 0.938903;
 neuron17_inter=-0.53027*C + 0.00955174*g0_tmp - 0.563878*g1_tmp + 0.548901*g2_tmp - 0.806912*g4_tmp - 0.00845191*g5_tmp - 0.572997*g8_tmp - 0.182402*h0_tmp + 0.15335*h1_tmp - 0.314541*h2_tmp - 0.0717287*h4_tmp - 0.159115*h5_tmp - 0.554228*h8_tmp - 0.281687;
 neuron18_inter=-0.207898*C + 0.797916*g0_tmp - 2.04719*g1_tmp + 1.19678*g2_tmp + 1.06492*g4_tmp - 1.27626*g5_tmp - 1.95839*g8_tmp - 0.38159*h0_tmp - 0.461441*h1_tmp + 0.176267*h2_tmp - 0.334078*h4_tmp + 0.0912082*h5_tmp - 0.261146*h8_tmp + 1.01236;
 neuron19_inter=-0.128154*C + 0.509777*g0_tmp + 0.0855947*g1_tmp + 0.735815*g2_tmp - 0.0623466*g4_tmp + 0.712028*g5_tmp + 0.337129*g8_tmp + 0.104461*h0_tmp - 0.282305*h1_tmp + 0.188168*h2_tmp - 0.135488*h4_tmp - 0.259414*h5_tmp + 0.132901*h8_tmp + 0.191056;
 neuron20_inter=-0.117734*C - 0.116155*g0_tmp - 0.409959*g1_tmp - 0.084894*g2_tmp - 0.787046*g4_tmp - 0.524127*g5_tmp - 0.535472*g8_tmp - 0.364489*h0_tmp - 0.4281*h1_tmp - 0.595516*h2_tmp - 0.330539*h4_tmp - 0.131407*h5_tmp - 0.394834*h8_tmp - 0.305505;
 neuron21_inter=0.460141*C - 0.997481*g0_tmp + 0.235976*g1_tmp + 0.24625*g2_tmp + 0.536111*g4_tmp + 0.119311*g5_tmp + 0.192027*g8_tmp - 0.477676*h0_tmp - 0.282707*h1_tmp - 0.712124*h2_tmp - 1.01671*h4_tmp + 0.220212*h5_tmp + 0.0666238*h8_tmp + 1.6231;
 neuron22_inter=0.504325*C + 0.324645*g0_tmp + 0.523542*g1_tmp + 0.292554*g2_tmp + 0.402982*g4_tmp + 0.564453*g5_tmp + 0.694711*g8_tmp - 0.0635742*h0_tmp + 0.194106*h1_tmp + 0.0323325*h2_tmp - 0.125937*h4_tmp + 0.0191739*h5_tmp + 0.395881*h8_tmp + 0.527968;
 neuron23_inter=0.188486*C + 0.110358*g0_tmp - 0.353322*g1_tmp + 0.559264*g2_tmp + 0.000615449*g4_tmp - 0.151802*g5_tmp - 0.101855*g8_tmp + 0.611713*h0_tmp + 0.57313*h1_tmp + 0.332578*h2_tmp - 0.00513878*h4_tmp + 0.623589*h5_tmp + 0.058403*h8_tmp + 0.0958466;
 neuron24_inter=-0.101515*C + 0.7479*g0_tmp - 0.49714*g1_tmp + 3.1435*g2_tmp - 2.13496*g4_tmp + 0.794806*g5_tmp - 2.01386*g8_tmp + 0.41484*h0_tmp + 0.29852*h1_tmp - 0.102732*h2_tmp + 0.154689*h4_tmp + 0.0576013*h5_tmp - 0.0769883*h8_tmp - 0.300263;
 neuron25_inter=0.0198519*C - 0.0062857*g0_tmp - 0.193127*g1_tmp + 0.611258*g2_tmp - 0.37475*g4_tmp - 0.436403*g5_tmp - 0.700516*g8_tmp - 0.371501*h0_tmp + 0.218624*h1_tmp - 0.472186*h2_tmp - 0.540593*h4_tmp + 0.017956*h5_tmp + 0.145158*h8_tmp - 0.198887;
neuron0_hidden1 = 1.0/(1.0+exp(-neuron0_inter));
neuron1_hidden1 = 1.0/(1.0+exp(-neuron1_inter));
neuron2_hidden1 = 1.0/(1.0+exp(-neuron2_inter));
neuron3_hidden1 = 1.0/(1.0+exp(-neuron3_inter));
neuron4_hidden1 = 1.0/(1.0+exp(-neuron4_inter));
neuron5_hidden1 = 1.0/(1.0+exp(-neuron5_inter));
neuron6_hidden1 = 1.0/(1.0+exp(-neuron6_inter));
neuron7_hidden1 = 1.0/(1.0+exp(-neuron7_inter));
neuron8_hidden1 = 1.0/(1.0+exp(-neuron8_inter));
neuron9_hidden1 = 1.0/(1.0+exp(-neuron9_inter));
neuron10_hidden1 = 1.0/(1.0+exp(-neuron10_inter));
neuron11_hidden1 = 1.0/(1.0+exp(-neuron11_inter));
neuron12_hidden1 = 1.0/(1.0+exp(-neuron12_inter));
neuron13_hidden1 = 1.0/(1.0+exp(-neuron13_inter));
neuron14_hidden1 = 1.0/(1.0+exp(-neuron14_inter));
neuron15_hidden1 = 1.0/(1.0+exp(-neuron15_inter));
neuron16_hidden1 = 1.0/(1.0+exp(-neuron16_inter));
neuron17_hidden1 = 1.0/(1.0+exp(-neuron17_inter));
neuron18_hidden1 = 1.0/(1.0+exp(-neuron18_inter));
neuron19_hidden1 = 1.0/(1.0+exp(-neuron19_inter));
neuron20_hidden1 = 1.0/(1.0+exp(-neuron20_inter));
neuron21_hidden1 = 1.0/(1.0+exp(-neuron21_inter));
neuron22_hidden1 = 1.0/(1.0+exp(-neuron22_inter));
neuron23_hidden1 = 1.0/(1.0+exp(-neuron23_inter));
neuron24_hidden1 = 1.0/(1.0+exp(-neuron24_inter));
neuron25_hidden1 = 1.0/(1.0+exp(-neuron25_inter));
neuron0_inter=-0.514765*neuron0_hidden1 - 0.563674*neuron10_hidden1 - 0.176909*neuron11_hidden1 - 0.352669*neuron12_hidden1 - 0.155618*neuron13_hidden1 - 0.66534*neuron14_hidden1 + 0.0470409*neuron15_hidden1 - 0.0397669*neuron16_hidden1 - 0.305878*neuron17_hidden1 - 0.651131*neuron18_hidden1 - 0.647258*neuron19_hidden1 - 0.565154*neuron1_hidden1 - 0.0999369*neuron20_hidden1 - 0.286166*neuron21_hidden1 - 0.334661*neuron22_hidden1 - 0.57133*neuron23_hidden1 - 0.340279*neuron24_hidden1 + 0.0444767*neuron25_hidden1 - 0.460307*neuron2_hidden1 - 0.590705*neuron3_hidden1 - 0.054278*neuron4_hidden1 - 0.441159*neuron5_hidden1 - 0.515313*neuron6_hidden1 - 0.378795*neuron7_hidden1 - 0.382973*neuron8_hidden1 + 0.0261936*neuron9_hidden1 - 0.289981;
 neuron1_inter=-0.0239911*neuron0_hidden1 + 0.272408*neuron10_hidden1 - 0.206267*neuron11_hidden1 + 0.101134*neuron12_hidden1 + 0.362508*neuron13_hidden1 + 0.383321*neuron14_hidden1 - 0.311666*neuron15_hidden1 - 0.0338378*neuron16_hidden1 + 0.539207*neuron17_hidden1 + 0.284657*neuron18_hidden1 - 0.018041*neuron19_hidden1 + 0.0465635*neuron1_hidden1 + 0.0971398*neuron20_hidden1 - 0.498753*neuron21_hidden1 - 0.349549*neuron22_hidden1 + 0.176395*neuron23_hidden1 + 1.14732*neuron24_hidden1 + 0.536985*neuron25_hidden1 - 0.0709252*neuron2_hidden1 - 0.145915*neuron3_hidden1 - 0.227715*neuron4_hidden1 - 0.646388*neuron5_hidden1 + 0.410809*neuron6_hidden1 - 0.153773*neuron7_hidden1 + 0.286891*neuron8_hidden1 - 0.360449*neuron9_hidden1 + 0.0461453;
 neuron2_inter=-0.57162*neuron0_hidden1 - 0.0183607*neuron10_hidden1 - 0.174198*neuron11_hidden1 - 0.573054*neuron12_hidden1 - 0.42205*neuron13_hidden1 - 0.0355217*neuron14_hidden1 - 0.287043*neuron15_hidden1 - 0.00439728*neuron16_hidden1 + 0.0234355*neuron17_hidden1 - 0.231891*neuron18_hidden1 - 0.437922*neuron19_hidden1 - 0.469043*neuron1_hidden1 + 0.0633575*neuron20_hidden1 - 0.391616*neuron21_hidden1 - 0.260266*neuron22_hidden1 - 0.22577*neuron23_hidden1 - 0.0895039*neuron24_hidden1 - 0.240413*neuron25_hidden1 - 0.688826*neuron2_hidden1 - 0.416172*neuron3_hidden1 - 0.269564*neuron4_hidden1 - 0.193202*neuron5_hidden1 - 0.130241*neuron6_hidden1 - 0.68087*neuron7_hidden1 - 0.570495*neuron8_hidden1 - 0.483747*neuron9_hidden1 - 0.291981;
 neuron3_inter=0.279649*neuron0_hidden1 - 0.168607*neuron10_hidden1 - 0.824491*neuron11_hidden1 + 0.0557888*neuron12_hidden1 - 0.718152*neuron13_hidden1 + 0.0790346*neuron14_hidden1 - 0.0672204*neuron15_hidden1 - 0.866437*neuron16_hidden1 - 0.150482*neuron17_hidden1 - 0.930461*neuron18_hidden1 + 0.188939*neuron19_hidden1 + 0.390103*neuron1_hidden1 - 0.130378*neuron20_hidden1 - 0.260786*neuron21_hidden1 + 0.0180841*neuron22_hidden1 - 0.322158*neuron23_hidden1 - 0.0626724*neuron24_hidden1 - 0.866296*neuron25_hidden1 + 0.266962*neuron2_hidden1 - 0.33643*neuron3_hidden1 + 0.0595959*neuron4_hidden1 + 0.0388067*neuron5_hidden1 - 0.64386*neuron6_hidden1 - 0.177677*neuron7_hidden1 - 0.548453*neuron8_hidden1 + 0.556156*neuron9_hidden1 - 0.0424731;
 neuron4_inter=-0.559355*neuron0_hidden1 - 0.348938*neuron10_hidden1 - 0.424671*neuron11_hidden1 - 0.419655*neuron12_hidden1 - 0.329205*neuron13_hidden1 - 0.577909*neuron14_hidden1 - 0.157346*neuron15_hidden1 - 0.419458*neuron16_hidden1 - 0.124133*neuron17_hidden1 - 0.39257*neuron18_hidden1 - 0.462502*neuron19_hidden1 - 0.481666*neuron1_hidden1 - 0.0975755*neuron20_hidden1 - 0.563956*neuron21_hidden1 - 0.392154*neuron22_hidden1 - 0.235675*neuron23_hidden1 - 0.53477*neuron24_hidden1 - 0.326252*neuron25_hidden1 - 0.0206725*neuron2_hidden1 - 0.148946*neuron3_hidden1 - 0.00565642*neuron4_hidden1 - 0.195301*neuron5_hidden1 + 0.0528918*neuron6_hidden1 + 0.0864109*neuron7_hidden1 - 0.571895*neuron8_hidden1 - 0.574544*neuron9_hidden1 - 0.244915;
 neuron5_inter=0.541907*neuron0_hidden1 - 0.49555*neuron10_hidden1 - 0.738139*neuron11_hidden1 + 0.367577*neuron12_hidden1 - 0.17206*neuron13_hidden1 + 0.283708*neuron14_hidden1 - 0.647607*neuron15_hidden1 + 0.213904*neuron16_hidden1 - 0.558959*neuron17_hidden1 + 0.183942*neuron18_hidden1 - 0.540802*neuron19_hidden1 - 0.102312*neuron1_hidden1 - 0.856755*neuron20_hidden1 - 0.868795*neuron21_hidden1 - 0.409383*neuron22_hidden1 + 0.291328*neuron23_hidden1 + 0.565587*neuron24_hidden1 - 0.337857*neuron25_hidden1 - 0.30521*neuron2_hidden1 - 0.021802*neuron3_hidden1 - 0.584028*neuron4_hidden1 - 0.423783*neuron5_hidden1 + 0.317577*neuron6_hidden1 - 0.15808*neuron7_hidden1 + 0.616662*neuron8_hidden1 - 0.0991145*neuron9_hidden1 - 0.190262;
 neuron6_inter=-0.305767*neuron0_hidden1 + 0.347255*neuron10_hidden1 + 0.0026829*neuron11_hidden1 + 0.463622*neuron12_hidden1 + 0.594851*neuron13_hidden1 - 0.217206*neuron14_hidden1 + 0.187523*neuron15_hidden1 - 0.82501*neuron16_hidden1 + 0.177093*neuron17_hidden1 - 0.602452*neuron18_hidden1 + 0.699749*neuron19_hidden1 + 0.0330545*neuron1_hidden1 + 0.618145*neuron20_hidden1 + 0.916683*neuron21_hidden1 + 0.0168118*neuron22_hidden1 - 0.0370107*neuron23_hidden1 + 0.128105*neuron24_hidden1 - 0.128345*neuron25_hidden1 + 0.250853*neuron2_hidden1 - 0.0756988*neuron3_hidden1 - 0.0781883*neuron4_hidden1 - 1.93245*neuron5_hidden1 - 0.820207*neuron6_hidden1 - 0.0481588*neuron7_hidden1 - 0.68472*neuron8_hidden1 + 0.187223*neuron9_hidden1 + 0.11599;
 neuron7_inter=-0.43881*neuron0_hidden1 - 0.554386*neuron10_hidden1 - 0.323363*neuron11_hidden1 - 0.173576*neuron12_hidden1 - 0.429885*neuron13_hidden1 - 0.337551*neuron14_hidden1 + 0.245215*neuron15_hidden1 - 0.198379*neuron16_hidden1 - 0.209613*neuron17_hidden1 - 0.382914*neuron18_hidden1 + 0.33232*neuron19_hidden1 + 0.0887294*neuron1_hidden1 - 0.440813*neuron20_hidden1 - 0.374899*neuron21_hidden1 + 0.135139*neuron22_hidden1 + 0.0970849*neuron23_hidden1 - 0.0855749*neuron24_hidden1 - 0.0831465*neuron25_hidden1 - 0.321745*neuron2_hidden1 - 0.44095*neuron3_hidden1 - 0.0625693*neuron4_hidden1 - 0.512067*neuron5_hidden1 - 0.39095*neuron6_hidden1 - 0.486319*neuron7_hidden1 - 0.449566*neuron8_hidden1 + 0.0118098*neuron9_hidden1 - 0.193921;
 neuron8_inter=-0.437704*neuron0_hidden1 - 0.101487*neuron10_hidden1 - 0.431294*neuron11_hidden1 - 0.0132279*neuron12_hidden1 - 0.0174879*neuron13_hidden1 - 0.432025*neuron14_hidden1 - 0.400772*neuron15_hidden1 - 0.661871*neuron16_hidden1 - 0.196733*neuron17_hidden1 - 0.29194*neuron18_hidden1 - 0.505444*neuron19_hidden1 - 0.360505*neuron1_hidden1 - 0.27216*neuron20_hidden1 + 0.00757164*neuron21_hidden1 - 0.458928*neuron22_hidden1 - 0.303821*neuron23_hidden1 - 0.67342*neuron24_hidden1 - 0.130295*neuron25_hidden1 - 0.347888*neuron2_hidden1 - 0.630808*neuron3_hidden1 - 0.522347*neuron4_hidden1 - 0.408906*neuron5_hidden1 - 0.277368*neuron6_hidden1 - 0.245284*neuron7_hidden1 - 0.325121*neuron8_hidden1 - 0.347075*neuron9_hidden1 - 0.288933;
 neuron9_inter=0.388972*neuron0_hidden1 - 0.654935*neuron10_hidden1 - 0.596881*neuron11_hidden1 + 0.352878*neuron12_hidden1 - 0.7922*neuron13_hidden1 + 0.595744*neuron14_hidden1 - 0.895875*neuron15_hidden1 - 0.620023*neuron16_hidden1 - 0.621728*neuron17_hidden1 - 0.388033*neuron18_hidden1 - 0.0757849*neuron19_hidden1 - 0.118886*neuron1_hidden1 - 0.777427*neuron20_hidden1 - 0.95967*neuron21_hidden1 + 0.0221709*neuron22_hidden1 + 0.323428*neuron23_hidden1 - 0.00511364*neuron24_hidden1 - 0.855289*neuron25_hidden1 + 0.0554234*neuron2_hidden1 - 0.0280737*neuron3_hidden1 - 0.602046*neuron4_hidden1 - 0.526189*neuron5_hidden1 - 0.61348*neuron6_hidden1 + 0.486842*neuron7_hidden1 - 0.164391*neuron8_hidden1 + 0.674829*neuron9_hidden1 + 0.0496665;
 neuron10_inter=-0.28098*neuron0_hidden1 - 0.303951*neuron10_hidden1 - 0.480757*neuron11_hidden1 - 0.74147*neuron12_hidden1 - 0.171797*neuron13_hidden1 - 0.616975*neuron14_hidden1 - 0.336218*neuron15_hidden1 - 0.71172*neuron16_hidden1 - 0.214867*neuron17_hidden1 - 0.0535084*neuron18_hidden1 - 0.093565*neuron19_hidden1 - 0.320285*neuron1_hidden1 - 0.476659*neuron20_hidden1 - 0.714832*neuron21_hidden1 - 0.0579673*neuron22_hidden1 - 0.631434*neuron23_hidden1 - 0.0630143*neuron24_hidden1 - 0.342166*neuron25_hidden1 - 0.670887*neuron2_hidden1 - 0.155238*neuron3_hidden1 + 0.0215737*neuron4_hidden1 - 0.0207662*neuron5_hidden1 - 0.708779*neuron6_hidden1 - 0.660504*neuron7_hidden1 - 0.226592*neuron8_hidden1 - 0.0337244*neuron9_hidden1 - 0.351174;
 neuron11_inter=-0.545678*neuron0_hidden1 - 0.0491613*neuron10_hidden1 + 0.0741384*neuron11_hidden1 - 0.39189*neuron12_hidden1 - 0.174149*neuron13_hidden1 - 0.0432277*neuron14_hidden1 - 0.359634*neuron15_hidden1 - 0.562784*neuron16_hidden1 - 0.144145*neuron17_hidden1 - 0.175286*neuron18_hidden1 - 0.330576*neuron19_hidden1 - 0.297504*neuron1_hidden1 - 0.112732*neuron20_hidden1 + 0.0114137*neuron21_hidden1 - 0.567576*neuron22_hidden1 - 0.44665*neuron23_hidden1 - 0.146501*neuron24_hidden1 - 0.0608283*neuron25_hidden1 - 0.636931*neuron2_hidden1 - 0.290809*neuron3_hidden1 - 0.434854*neuron4_hidden1 - 0.0758991*neuron5_hidden1 + 0.0798879*neuron6_hidden1 - 0.666652*neuron7_hidden1 - 0.156024*neuron8_hidden1 - 0.69198*neuron9_hidden1 - 0.321427;
neuron0_hidden1 = 1.0/(1.0+exp(-neuron0_inter));
neuron1_hidden1 = 1.0/(1.0+exp(-neuron1_inter));
neuron2_hidden1 = 1.0/(1.0+exp(-neuron2_inter));
neuron3_hidden1 = 1.0/(1.0+exp(-neuron3_inter));
neuron4_hidden1 = 1.0/(1.0+exp(-neuron4_inter));
neuron5_hidden1 = 1.0/(1.0+exp(-neuron5_inter));
neuron6_hidden1 = 1.0/(1.0+exp(-neuron6_inter));
neuron7_hidden1 = 1.0/(1.0+exp(-neuron7_inter));
neuron8_hidden1 = 1.0/(1.0+exp(-neuron8_inter));
neuron9_hidden1 = 1.0/(1.0+exp(-neuron9_inter));
neuron10_hidden1 = 1.0/(1.0+exp(-neuron10_inter));
neuron11_hidden1 = 1.0/(1.0+exp(-neuron11_inter));
neuron0_inter=-0.0862154*neuron0_hidden1 + 0.24862*neuron10_hidden1 - 0.0218085*neuron11_hidden1 + 0.286992*neuron1_hidden1 - 0.290759*neuron2_hidden1 + 0.437822*neuron3_hidden1 - 0.170477*neuron4_hidden1 + 0.763485*neuron5_hidden1 - 0.657715*neuron6_hidden1 - 0.353078*neuron7_hidden1 + 0.00172513*neuron8_hidden1 + 1.03169*neuron9_hidden1 + 0.0345373;
 neuron1_inter=0.0185267*neuron0_hidden1 - 0.0385663*neuron10_hidden1 - 0.156288*neuron11_hidden1 - 0.6925*neuron1_hidden1 + 0.0784887*neuron2_hidden1 + 0.508425*neuron3_hidden1 + 0.471731*neuron4_hidden1 - 0.160153*neuron5_hidden1 + 0.913389*neuron6_hidden1 + 0.455549*neuron7_hidden1 + 0.230239*neuron8_hidden1 + 0.528524*neuron9_hidden1 + 0.122053;
 neuron2_inter=-0.139689*neuron0_hidden1 + 0.213154*neuron10_hidden1 - 0.191629*neuron11_hidden1 + 0.53807*neuron1_hidden1 + 0.0651101*neuron2_hidden1 - 0.0820016*neuron3_hidden1 + 0.00927164*neuron4_hidden1 + 0.0635615*neuron5_hidden1 + 0.310184*neuron6_hidden1 + 0.342152*neuron7_hidden1 - 0.333201*neuron8_hidden1 + 0.00447658*neuron9_hidden1 + 0.0538922;
phase = 1.0/(1.0+exp(-neuron0_inter));
ux = 1.0/(1.0+exp(-neuron1_inter));
uy = 1.0/(1.0+exp(-neuron2_inter));
phase = (phase - -0.00000045)/0.99894709;
ux    = (ux - 0.00397558)/191.14698600;
uy    = (uy - 0.47949121)/544.19432410;

// END OF PYTHON GENERATED CODE
EVelocity(ux, uy, phase);
}

#ifdef OPTIONS_Outflow
	CudaDeviceFunction void EConvective()
	{
		real_t U_local = U(-1,0);
		real_t invU = 1.0 / (1 + U_local) ;
		<?R if (Options$Outflow){
			C(g, (g_old + U_loc*g_n)*U_inv)
			C(h, (h_old + U_loc*h_n)*U_inv)

			C(g_old,g)
			C(h_old,h)}
		?>

	}

	CudaDeviceFunction void NConvective()
	{
		real_t U_local = V(0,-1);
		real_t invU = 1.0 / (1 + U_local) ;
		<?R if (Options$Outflow){
			C(g, (g_old + U_loc*g_n1)*U_inv)
			C(h, (h_old + U_loc*h_n1)*U_inv)

			C(g_old,g)
			C(h_old,h)}
		?>

	}

	CudaDeviceFunction void ENeumann()
	{
		// Set the values at the boundary nodes to those of the post-stream inside node 
		//	As a result of this we need to manually stream to values here.
		<?R if (Options$Outflow) {
		C(g, PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],")",sep="")))
		C(h, PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")",sep="")))
		} ?>

	}
#endif

CudaDeviceFunction void WVelocity()
{
    U = VelocityX;
    V = 0;
<?R
        n = c(-1,0)
        g = PV(DensityAll$name[DensityAll$group=="g"])
        U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy")])
        u = PV(c("U","V"))
        EQ = MRT_eq(U, PV(1), u)
        geq = EQ$feq
        bounce = Bounce(U)
        sel = as.vector( (U %*% n) < 0)

        sel2 = as.vector( ( U %*% n) == 0)  
        exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
        Unknowns = 1.0/max(colSums(U[sel2,]^2)) # should be 6 for q27, 4 for q15
        Nmat = t(U[sel,]) %*% U[sel,]

        C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - 0.5* (exM %*% solve(Nmat) %*% t(U))[sel])
    ?>
    <?R
        h = PV(DensityAll$name[DensityAll$group=="h"])
        U_PF = U
        pf = PV("PhaseField_init")
        EQ_h = MRT_eq(U_PF,PV(1),u)
        n = c(-1,0)
        heq = pf * EQ_h$feq
        bounce = Bounce(U_PF)
        sel = as.vector( (U_PF %*% n) < 0)

        sel2 = as.vector( ( U_PF %*% n) == 0)   
        exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
        Unknowns = 1.0/sum(sel)

        C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
    ?>
}

CudaDeviceFunction void NVelocity()
{
    U = 0;
    V = VelocityY;
<?R
        n = c(0,1)
        g = PV(DensityAll$name[DensityAll$group=="g"])
        U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy")])
        u = PV(c("U","V"))
        EQ = MRT_eq(U, PV(1), u)
        geq = EQ$feq
        bounce = Bounce(U)
        sel = as.vector( (U %*% n) < 0)

        sel2 = as.vector( ( U %*% n) == 0)  
        exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
        Unknowns = 1.0/max(colSums(U[sel2,]^2)) # should be 6 for q27, 4 for q15
        Nmat = t(U[sel,]) %*% U[sel,]

        C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - 0.5* (exM %*% solve(Nmat) %*% t(U))[sel])
    ?>
    <?R
        h = PV(DensityAll$name[DensityAll$group=="h"])
        U_PF = U
        pf = PV("PhaseField_init")
        EQ_h = MRT_eq(U_PF,PV(1),u)
        n = c(0,1)
        heq = pf * EQ_h$feq
        bounce = Bounce(U_PF)
        sel = as.vector( (U_PF %*% n) < 0)

        sel2 = as.vector( ( U_PF %*% n) == 0)   
        exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
        Unknowns = 1.0/sum(sel)

        C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
    ?>
}

CudaDeviceFunction void MovingWall_S_Dirichlet(){
	// The bounce-back formula for a Dirichlet boundary condition with a prescribed wall velocity
	// eq 5.26 p180 from The Lattice Boltzmann Method: Principles and Practice
	// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	// TODO: IMPLEMENT ACTUAL BOUNDARY CONDITION
	g[2] = g[4];
	g[5] = g[7] + VelocityX/6.0;
	g[6] = g[8] - VelocityX/6.0;

	h[2] = h[4];
	h[5] = h[7];
	h[6] = h[8];
}

CudaDeviceFunction void MovingWall_N_Dirichlet(){
	// The bounce-back formula for a Dirichlet boundary condition with a prescribed wall velocity
	// eq 5.26 p180 from The Lattice Boltzmann Method: Principles and Practice
	// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	// TODO: IMPLEMENT ACTUAL BOUNDARY CONDITION
	g[4] = g[2];
	g[7] = g[5] - VelocityX/6.0;
	g[8] = g[6] + VelocityX/6.0;

	h[4] = h[2];
	h[7] = h[5];
	h[8] = h[6];
}

CudaDeviceFunction void BounceBack()
{
	vector_t p1,p2;
	if((NodeType & NODE_BODY) == NODE_Body) {
		p1.x = g[8] +g[1] +g[5] -g[6] -g[3] -g[7];
		p1.y = g[5] +g[2] +g[6] -g[7] -g[4] -g[8];

		vector_t gradPhi = calcGradPhi(); // Phase field gradient
		real_t rho = calcRho(PhaseF);
		real_t tau = calcTau(PhaseF, rho);
		real_t p = getNormalizedPressure() ; // normalized pressure
		vector_t Fhydro;
		#ifdef OPTIONS_BGK
			if (NodeType & NODE_BGK) { // Not Implemented
			}
		#elif OPTIONS_CM
			if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, PhaseF, rho, tau,  calcMu(PhaseF), p);}
		#else
			if (NodeType & NODE_MRT) { Fhydro = calcTotalHydrodynamicForceMRT(gradPhi, PhaseF, rho, tau,  calcMu(PhaseF), p);}
		#endif
		p1.x = p1.x*rho + 0.5*Fhydro.x;
		p1.y = p1.y*rho + 0.5*Fhydro.y;
	}

	real_t tmp;
	tmp = g[1];
	g[1] = g[3];
	g[3] = tmp;
	tmp = g[2];
	g[2] = g[4];
	g[4] = tmp;
	tmp = g[5];
	g[5] = g[7];
	g[7] = tmp;
	tmp = g[6];
	g[6] = g[8];
	g[8] = tmp;

	tmp = h[1];
	h[1] = h[3];
	h[3] = tmp;
	tmp = h[2];
	h[2] = h[4];
	h[4] = tmp;
	tmp = h[5];
	h[5] = h[7];
	h[7] = tmp;
	tmp = h[6];
	h[6] = h[8];
	h[8] = tmp;

	//Summing the difference in momentum before/after collision
	if((NodeType & NODE_BODY) == NODE_Body) {
		p2.x = g[8] +g[1] +g[5] -g[6] -g[3] -g[7];
		p2.y = g[5] +g[2] +g[6] -g[7] -g[4] -g[8];

		vector_t gradPhi = calcGradPhi(); // Phase field gradient
		real_t rho = calcRho(PhaseF);
		real_t tau = calcTau(PhaseF, rho);
		real_t p = getNormalizedPressure() ; // normalized pressure
		vector_t Fhydro;
		#ifdef OPTIONS_BGK
			if (NodeType & NODE_BGK) { // Not Implemented
			}
		#elif OPTIONS_CM
			if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, PhaseF, rho, tau,  calcMu(PhaseF), p);}
		#else
			if (NodeType & NODE_MRT) { Fhydro = calcTotalHydrodynamicForceMRT(gradPhi, PhaseF, rho, tau,  calcMu(PhaseF), p);}
		#endif

		p2.x = p2.x*rho + 0.5*Fhydro.x;
		p2.y = p2.y*rho + 0.5*Fhydro.y;

		AddToFDrag(-(p2.x-p1.x));
		AddToFLift(-(p2.y-p1.y));
		AddToFTotal(sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y)));
	}
}
